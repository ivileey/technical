# JVM

## 1.运行时数据区域（内存模型）

> 1.8方法区改成元空间。Class对象和static成员变量都在堆内存中。
>
> 方法调用完成时，当前栈桢就被用来恢复调用者的状态，都恢复哪些呢？恢复局部变量表、操作数栈 和 程序计数器(pc指针)，而这个程序计数器要适当地增加，来指向下一条指令(也就是调用函数的下一句)。使调用者方法能够正常地继续执行下去，而且返回值push到了调用方法的操作数栈中。
>
> Native方法也是方法，当他被调用了后，会进入本地方法栈。有的虚拟机会把虚拟机栈和本地方法栈合为一个。当Native方法在本地方法栈里执行完时，也会根据类似的机制让PC重新指向调用指令后面的一条指令

1. 堆（Heap）：堆是JVM内存中最大的一块内存空间，用于存放对象实例，该内存被所有线程共享，几乎所有对象和数组都分配到堆内存中，堆被划分为，新生代和老年代，新生代被分为Eden区和Survivor区，Survivor由From Survivor和To Survivor区。
2. 方法区（method Area） -> 元数据区：用来存放已被虚拟机加载的类相关信息，包括类信息、常量池（字符串常量池以及所有的基本类型的常量池）、运行时常量池。类信息包括了类的版本、字段、方法、接口和父类信息。会发生OOM，一直向常量池加入数据。
3. 程序计数器：程序计数器是一块很小的内存空间，用来记录各个线程执行的字节码地址，例如，分支、循环、跳转、异常、线程恢复都依赖于计数器。
4. 虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。StackOverflowError异常和OOM异常。
5. 本地方法栈：本地方法栈用于本地方法的调用。

### java的对象都是在堆上分配的吗？

java会有一个逃逸分析，通过逃逸分析，Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

**在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。**

**通过标量替换，原本的一个对象，被替换成了多个成员变量。而原本需要在堆上分配的内存，也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。**



jdk1.8将方法区改成元数据区，还有直接内存，使用的是本地内存，不是虚拟机的内存。

## 2.垃圾回收机制

> 对于程序计数器、虚拟机栈、本地方法栈的内存随着线程的生命周期结束自然回收。
>
> java堆和方法区不一定。

在java中程序员不需要显示的去释放一个对象的内存，而是由虚拟机自动执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有任何引用的对象，并将它们添加到要回收的集合中，进行回收。

## 3. 垃圾回收算法

- 标记清除算法：标记无用的对象，然后进行清除回收。效率不高，无法清除垃圾碎片。
- 复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。内存使用率不高，只有原来的一半。
- 标记-整理算法：标记无用的对象，让所有存活的对象都向一端移动，然后直接清除掉边界以外的内存。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

## 4.MinorGC和FullGC的触发条件

> MinorGC:回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度一般比较快。
>
> Full GC：回收老年代和新生代老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。

Minor GC触发条件：当Eden区满时触发Minor GC

Full GC触发条件：

1. 调用System.gc时
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向 To Space区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

## 5.GC中的Stop the World（STW）

当GC线程启动时（即进行垃圾收集），应用程序都要暂停.

1.使用复制算法对对象进行移动时。

2.从根节点枚举对象时

## 6.各垃圾回收器的特点及区别

- Serial收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。
- ParNew收集器（复制算法）：新生代并行收集器，实际上是Serial收集器的多线程版本。
- Parrallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU。
- Serial Old收集器（标记-整理算法）：老年代并行收集器。
- Paraller Old收集器（标记-整理算法）：老年代并行收集器。
- CMS收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间的收集器。
- G1收集器（标记-整理算法）：Java堆并行收集器。

## 7.简述java类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

包括加载，验证，准备，解析，初始化5个阶段。

## 8. 什么是双亲委派模型？

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

## 9.对象的创建过程

类加载检查 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行init方法

## 10.GCroots

可达性分析算法 和GC Roots直接或间接关联的对象是有效对象，反之则是无效对象。
可作为GCRoots的对象

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI（Native方法引用的对象）
- ·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如
  NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。
- 所有被同步锁(synchronized关键字)持有的对象。
- 反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。

## 11.垃圾收集器

### 1. Serial 收集器

Serial 翻译为串行，也就是说它以串行的方式执行。

它是单线程的收集器，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。

### 2. ParNew 收集器

它是 Serial 收集器的多线程版本。

它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。

### 3. Parallel Scavenge 收集器

与 ParNew 一样是多线程收集器。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。

缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。

可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

### 4. Serial Old 收集器

是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

### 5. Parallel Old 收集器

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 6. CMS 收集器

CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。

分为以下四个流程：

- 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
- 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
- 并发清除：不需要停顿。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

### 7.G1 收集器

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。

G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。