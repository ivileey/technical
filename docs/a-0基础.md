# java内存模型

- Java 内存模型，描述的是多线程允许的行为
- JVM 内存结构，描述的是线程运行所设计的内存空间

# Java基础

## 1.Java的8种基本类型

- boolean 1位
- byte 1字节8位
- short 2字节 16位
- char 2字节 16位
- int 4字节 32位
- float 4字节 32位

- double 8字节 64位
- long 8字节 64位

## 2.jdk1.8/jdk1.7都分别新增了哪些特性



## 3.Exception和Error

Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。

Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。

Exception又分为运行时异常，编译能通过一旦运行则终止。受检查的异常，要么try/catch捕获要么throw抛出。

## 4.String，StringBuffer，StringBuilder的区别

String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；

StringBuffer类是线程安全的，StringBuilder不是线程安全的；

需要经常改变字符串不要用String，String对象的拼接实际是StringBuffer对象的拼接。

StringBuilder在方法内部完成“+”的操作，StringBuffer在全局变量。

## 5.replace和replaceAll的区别

replace是基于字符的替换，replaceAll是基于正则表达式的替换。

##  6.java中Object类中有哪些方法？作用分别是什么？

Object类是一个特殊的类是所有类的父类。主要提供11个方法。

```
public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。

public native int hashCode() 
//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。
public boolean equals(Object obj)
//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。

protected native Object clone() throws CloneNotSupportedException
//naitive方法，用于创建并返回当前对象的一份拷贝。默认为浅拷贝，深拷贝要实现Cloneable接口。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。

public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。

public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。

public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。

public final native void wait(long timeout) throws InterruptedException
//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。

public final void wait(long timeout, int nanos) throws InterruptedException
//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。

public final void wait() throws InterruptedException
//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念

protected void finalize() throws Throwable { }
//实例被垃圾回收器回收的时候触发的操作
```

## 7.接口和抽象类的区别，接口可以替代抽象类吗？抽象类可以替代接口吗？为什么？

## 8.原码、补码、反码？

> 原码、反码和补码的出现是为了让机器只做加法，比如做1-1使用原码得到的是-2。使用反码得到的是-0。使用补码计算得到是0

- 正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
- 正数的补码是其本身，负数的补码在其原码的基础上符号位不变，其余各位取反+1

整数在计算机中使用补码表示。

## 9.浮点数在计算机中表示

N = 尾数 * 基数^阶码

浮点数在机器中的存储格式为数字符号位+阶符+阶码+尾数

浮点数无法精确表示 0.1无法通过1 * 2^ -1表示，会采用一种无限逼近的办法，0.1就等一1* 2的-4次方+1* 2的-5

次方这样加下去。

## OS

### 1.浮点数在计算机中怎么表示？

N = 尾数 * 基数^阶码

浮点数在机器中的存储格式为数字符号位+阶符+阶码+尾数

浮点数无法精确表示 0.1无法通过1 * 2^ -1表示，会采用一种无限逼近的办法，0.1就等一1* 2的-4次方+1* 2的-5

次方这样加下去。

### 2.一个正数的原码和补码一样吗？负数呢？负数怎么算补码的？

> 原码、反码和补码的出现是为了让机器只做加法，比如做1-1使用原码得到的是-2。使用反码得到的是-0。使用补码计算得到是0

- 正数的反码是其本身，负数的反码是在其原码的基础上，符号位不变，其余各个位取反。
- 正数的补码是其本身，负数的补码在其原码的基础上符号位不变，其余各位取反+1

整数在计算机中使用补码表示。

###  3. 为什么要用补码？

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运[算法](http://lib.csdn.net/base/datastructure)则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

### 网络

私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。

A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255

B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255

C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255

## 参考文献

1.[进程上下文切换](https://zhuanlan.zhihu.com/p/52845869)