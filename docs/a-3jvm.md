# JVM

## 1.运行时数据区域（内存模型）

1. 堆（Heap）：堆是JVM内存中最大的一块内存空间，用于存放对象实例，该内存被所有线程共享，几乎所有对象和数组都分配到堆内存中，堆被划分为，新生代和老年代，新生代被分为Eden区和Survivor区，Survivor由From Survivor和To Survivor区。
2. 方法区（method Area）：用来存放已被虚拟机加载的类相关信息，包括类信息、常量池（字符串常量池以及所有的基本类型的常量池）、运行时常量池。类信息包括了类的版本、字段、方法、接口和父类信息。会发生OOM，一直向常量池加入数据。
3. 程序计数器：程序计数器是一块很小的内存空间，用来记录各个线程执行的字节码地址，例如，分支、循环、跳转、异常、线程恢复都依赖于计数器。
4. 虚拟机栈：是线程私有的内存空间，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。StackOverflowError异常和OOM异常。
5. 本地方法栈：本地方法栈用于本地方法的调用。

## 2.垃圾回收机制

> 对于程序计数器、虚拟机栈、本地方法栈的内存随着线程的生命周期结束自然回收。
>
> java堆和方法区不一定。

在java中程序员不需要显示的区释放一个对象的内存，而是由虚拟机自动执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描那些没有任何饮用的对象，并将它们添加到要回收的集合中，进行回收。

## 3. 垃圾回收算法

- 标记清除算法：标记无用的对象，然后进行清除回收。效率不高，无法清除垃圾碎片。
- 复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。内存使用率不高，只有原来的一半。
- 标记-整理算法：标记无用的对象，让所有存活的对象都向一端移动，然后直接清除掉边界以外的内存。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。

## 4.MinorGC和FullGC的触发条件

> MinorGC:回收新生代，因为新生代对象存活时间很短，因此Minor GC会频繁执行，执行速度一般比较快。
>
> Full GC：回收老年代和新生代老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多

Minor GC触发条件：当Eden区满时触发Minor GC

Full GC触发条件：

1. 调用System.gc时
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向 To Space区复制时，对象大小大于 To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。

## 5.GC中的Stop the World（STW）

当GC线程启动时（即进行垃圾收集），应用程序都要暂停.

1.使用复制算法对对象进行移动时。

2.从根节点枚举对象时

## 6.各垃圾回收器的特点及区别

- Serial收集器（复制算法）：新生代单线程收集器，标记和清理都是单线程，优点是简单高效。
- ParNew收集器（复制算法）：新生代并行收集器，实际上是Serial收集器的多线程版本。
- Parrallel Scavenge收集器（复制算法）：新生代并行收集器，追求高吞吐量，高效利用CPU。
- Serial Old收集器（标记-整理算法）：老年代并行收集器。
- Paraller Old收集器（标记-整理算法）：老年代并行收集器。
- CMS收集器（标记-清除算法）：老年代并行收集器，以获取最短回收停顿时间的收集器。
- G1收集器（标记-整理算法）：Java堆并行收集器。

## 7.简述java类加载机制

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。

包括加载，验证，准备，解析，初始化5个阶段。

## 8. 什么是双亲委派模型？

当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。

## 9.对象的创建过程

类加载检查 -> 分配内存 -> 初始化零值 -> 设置对象头 -> 执行init方法