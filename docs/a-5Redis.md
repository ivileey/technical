# Redis

## Redis的作用

1. 分布式锁 当key不存在是将key的值设置为value，返回1，当key存在不做任何动作。当返回1的时候代表获取锁，做完以后删除key表示释放锁。
2. 计数器：可以看每一个问题被浏览的次数
3. 消息队列
4. 可以使用set实现共同关注的人

## 1.Redis的应用场景

- String类型一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。
- List类型发布与订阅或者说消息队列、慢查询
- hash系统中对象数据的存储
- set需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景
- zset 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

## 2.Redis支持的数据结构

String，List，hash，set，zset

- String：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（simple dynamic string，**SDS**）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。
- list：**list** 即是 **链表**。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 **LinkedList**，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 **双向链表**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
- hash：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，**特别适合用于存储对象**，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。
- set： set 类似于 Java 中的 `HashSet` 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。
- zset： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。

## 3.Zset的数据结构

Zset底层维护的是一种跳跃表，由多个有序链表组成插入速度非常快，从上层指针开始找，找到对应区间之后去下层开始找。不需要旋转，支持无锁操作。

## 4.Redis的数据过期策略

 volatile-lru： 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
 allkeys-lru：从所有数据集中挑选最近最少使用的数据进行淘汰
 allkeys-random：从所有数据集中任意选择数据进行淘汰
 noeviction：禁止驱逐数据，新写入数据操作会报错

 4.0 版本后增加以下两种：

 volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

## 5.Redis的持久化机制

RDB持久化，将某个时间点的所有数据都存放到硬盘上。

AOF持久化，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据

## 6.Redis的LRU过期策略的具体实现

正常的lru：实现一个双向链表，每次有一个key被访问之后就将key放到链表的头部，当内存不够用时，从链表尾部淘汰key。

Redis中的LRU：

## 7.如何解决Redis缓存雪崩，缓存穿透问题

### 缓存雪崩

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

### 缓存穿透

布隆过滤器，**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

## 8.Redis中的管道pipeline

Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。

## 9.Redis为什么快

1. 数据库的工作模式可以分为两种一种是硬盘数据库，一种是内存数据库，硬盘数据库就是内存中存放数据的索引，数据是存放在硬盘中，redis就是内存数据库，将数据直接存放到内存中。

2. Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS
3. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
4. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
5. 使用多路I/O复用模型，非阻塞IO；
6. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求

### 内存为什么快

内存的速度之所以比硬盘的速度快（不是快一点，而是快很多），是因为它们的存储原理和读取方式不一样。

- 硬盘是机械结构，通过磁头的转动读取数据。一般情况下台式机的硬盘为每分钟 7200 转，而笔记本的硬盘为每分钟 5400 转。
- 而内存是没有机械结构的，内存是通过电存取数据的。

