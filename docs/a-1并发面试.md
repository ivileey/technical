# 并发

## 线程基础

### 1.什么是线程线程死锁?如何避免死锁?

多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放

1. 破坏互斥条件
2. 破坏请求与保持条件
3. 破坏不剥夺条件
4. 破坏循环等待条件

### 2. volatile的作用

volatile关键字可以防止JVM的指令重排，还有一个重要作用就是保证变量的可见性，因为CPU具有L1，L2，L3缓存，volatile关键字可以保证被修改的元素内容直接写入到主内存中，根据缓存一致性协议使其他工作内存里缓存了该共享变量的地址数据无效，从而实现内存可见性。

### 3.Atomic类如何保证原子性（CAS操作）

依赖于UnSafe类，实现原子类，Unsafe类是由native方法实现的。

CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。

CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。

由于volatile关键字不具有原子性，当i++操作时会产生问题，所以引入CAS。AtomicInteger。

1.ABA问题 ，利用客观锁加版本号解决。

2.循环时间长开销大。利用自旋次数或超时时间解决。

3.只能保证一个变量的原子操作 利用锁来解决

### 4.synchronized和Lock的区别

- synchronized是Java内置的关键字，在JVM层面，Lock是个Java类。
- synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。
- synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。
- 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。

### 5.线程之间如何通信？

- volatile关键字
- synchronized
- Lock下的等待/通知机制实现

## 锁

## 线程池

### 1.为什么要使用线程池？

**池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。**

- 降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- 提高响应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- 提高线程的可管理性，使用线程池可以进行统一的分配，调优和监控。

### 2.核心线程池ThreadPoolExecutor的参数？

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

`ThreadPoolExecutor`其他常见参数:

- **`keepAliveTime`**:当普通线程池中的线程数量大于 `corePoolSize`核心线程池数量 的时候，如果这时没有新的任务提交，普通线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；

- **`unit`** : `keepAliveTime` 参数的时间单位。

- **`threadFactory`** :executor 创建新线程的时候会用到。

- **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。

### 3.ThreadPoolExecutor的工作流程?

首先检查核心线程池是否已满，没有满创建线程，满了的话检查等待队列是否已满，没有满则加入等待队列，满了则检查普通线程池是否已满，没满则创建线程。 

### 4.如何控制线程池线程的优先级



