#  Mysql

## 事务

### 什么是数据库的事务

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。要么都成功要么都失败

### 事物的四大特性(ACID)介绍一下?

1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；
3. **隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 什么是脏读？幻读？不可重复读？

- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。

| 隔离级别         | 脏读 | 不可重复读 | 幻影读 |
| ---------------- | ---- | ---------- | ------ |
| READ-UNCOMMITTED | √    | √          | √      |
| READ-COMMITTED   | ×    | √          | √      |
| REPEATABLE-READ  | ×    | ×          | √      |
| SERIALIZABLE     | ×    | ×          | ×      |

**SQL 标准定义了四个隔离级别：**

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。

这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。

InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。

### 原子性实现原理：Undo log

当执行delete时在Undo log中就插入一条insert语句

当执行insert语句时在undo log中就插入一条delete语句

### 持久性实现原理 ： Redo log

和undo log相反，redo log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。

### 隔离性实现原理：锁

- 在mysql中，锁可以分为两类：

  - 共享锁：共享锁定是将对象数据变为只读形式，不能进行更新，所以也称为读取锁定。

    ```
    select * from student where id = 1 lock in share mode;
    ```

  - 排他锁：排他锁定是当执行INSERT/UPDATE/DELETE的时候，其它事务不能读取该数据，因此也称为写入锁定

    ```
    select * from student where id = 1 for update;
    ```

  - 意向共享锁：表示事务准备给数据加入共享锁，也就是说一个数据在加共享锁之前必须先取得该表的IS锁。

  - 意向排他锁：表示事务准备给数据加入排他锁，也就是说一个数据行加排它锁之前必须先取得该表的IX锁。

  - 自增锁：针对自增长的一个特殊的表级别锁

    ```
    SHOW VARIABLES LIKE 'innodb_autoinc_lock_mode';
    ```

    

- 锁的粒度：锁定对象的大小是锁的粒度

  - 记录
  - 表
  - 数据库

### 故障及故障恢复

- 撤销事务undo：将事务更新的所有数据项恢复为日志中的旧值
- 重做事务redo：将事务更新的所有数据项恢复为日志中的新值
- 事务正常回滚/因事务故障中止将进行redo
- 系统从崩溃中恢复时将先进行redo再进行undo

### MVCC多版本并发控制

事务隔离机制的实现基于锁机制和并发调度。并发调度使用的是MVCC多版本并发控制，通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。用以实现提交读和可重复读两种隔离级别。MVCC利用多版本思想，写操作更新最新的版本快照，读操作去读旧版本快照。

在MVCC中事务的修改操作（DELETE、Insert、Update）会为数据行新增一个版本快照。

#### 版本号

- 系统版本号SYS_ID：是一个递增的数字，每开启一个新的事务，系统版本号就会自动递增。
- 事务版本号TRX_ID：事务开始时的系统版本号。

#### Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

#### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

## MySQL的存储引擎选择
- 不要多说，选InnoDB
## 选择优化的数据类型
- 更小的通常更好
- 简单就好
- 尽量避免NULL
### 整数类型
- TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT
- 分别是8，16，24，32，64位
- UNSIGNED属性，表示不允许负值，正数上限范围提高一倍
- MySQL可以为整数类型指定宽度INT（11），对大多数应用这是没有意义的，不会限制值的合法范围，只是规定了显示字符的个数。
### 实数类型
- DECIMAL用于存储精确的浮点数，是在MYSQL服务器实现的，不是CPU，因此性能低下
- FLOAT和DOUBLE是不精确的
- 可以使用BIGINT乘上相应的倍数来代替，DECIMAL

### 字符串类型
- VARCHAR和CHAR
-  存储在磁盘和内存中的方式和使用的存储引擎有关
- VARCHAR用于存储可变长字符串，需要使用1或2个额外的字节记录字符串的长度。
- CHAR 定长字符串。

### 使用枚举(ENUM)代替字符串类型

### 日期和时间类型
- DATETIME能保存大范围的值
- TIMESTAMP 只使用4个字节的存储空间，通常尽量使用TIMESTAMP，空间效率高

## 二叉树，B树，B+树

### B树的特点

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;B树是多叉的。

### B+ 树

- B+跟B树不同B+树的**非叶子**节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个**非叶子**节点所能保存的关键字大大增加；
- B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；
- B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;
- B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。
- B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
- **B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

## 参考链接

1. 《高性能MySQL》
2. 《mysql innodb引擎》
3. [Mysql面试](https://thinkwon.blog.csdn.net/article/details/104778621)