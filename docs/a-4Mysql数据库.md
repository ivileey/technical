# 数据库

## 1.事务的基本要素

事务的基本要素（ACID）：

- 原子性：要么都成功要么都失败，通过undo log实现
- 一致性：事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
- 隔离型：并发访问数据库时，一个用户的事务不被其他事务所干扰。
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的。通过Redo log实现。

## 2.事务的隔离级别

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**

## 3.如何解决事务的并发问题(脏读，幻读)

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 4.MVCC多版本并发控制

事务隔离机制的实现基于锁机制和并发调度。并发调度使用的是MVCC多版本并发控制，通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。用以实现提交读和可重复读两种隔离级别。MVCC利用多版本思想，写操作更新最新的版本快照，读操作去读旧版本快照。

在MVCC中事务的修改操作（DELETE、Insert、Update）会为数据行新增一个版本快照。

### 版本号

- 系统版本号SYS_ID：是一个递增的数字，每开启一个新的事务，系统版本号就会自动递增。
- 事务版本号TRX_ID：事务开始时的系统版本号。

### Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

## 5.binlog,redolog,undolog都是什么，起什么作用？

- redo log(重做日志)：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redolog进行重做，从而达到事务的持久性这一特性。
- binlog(归档日志)：用于复制，在主从复制中，从库利用主库上的binlog进行重播。实现主从同步。用于数据库基于时间点的还原。
- undo log(回滚日志)：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

## 6.InnoDB的行锁/表锁

- **行级锁**：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，加锁的开销最大。行级锁分为共享锁排他锁。

  特点：开销大，加锁慢，会出现死锁；锁定粒度最小，发生冲突的概率最低，并发度也最高。

- **表级锁**：表级锁是Mysql中锁定粒度最大的一种锁，表示对整张表加锁，实现简单，资源消耗较少。表级锁分为共享锁和排他锁。

  特点：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

### MySQL中InnoDB引擎的行锁是怎么实现的？

  答：InnoDB是基于索引来完成行锁

  例: select * from tab_with_index where id = 1 for update;

  for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

## 7.myisam和innodb的区别，什么时候选择myisam？

### myisam

1. Myisam提供了大量的特性，包括全文索引、压缩、空间函数。但Myisam不支持事务和行级锁，具有一个毫无疑问的缺陷就是崩溃后无法安全恢复。对于只读的数据，或者表比较小，可以忍受修复操作可以使用myisam。

2. myisam将表存储在两个文件中，数据文件和索引文件。myisam表可以存储的行记录数一般受限于可用的磁盘空间或者操作系统单个文件的最大尺寸。

3. mysiam对整张表加锁，读取时对需要读到的所有表加共享锁，写入时对表加排他锁。但是在表读取查询的同时，也可以往表中插入新的记录。

4. 可以基于前500个字符创建索引，基于分词创建索引，可以支持复杂查询。

5. 延迟更新索引键：每次修改执行完成时不会立刻将修改的索引数据写入磁盘，而是会写入到内存的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应索引块写入到磁盘。这种操作可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。
6. myisam压缩表：压缩表是不能修改的（除非解压缩），可以极大的减少磁盘空间占用，因此可以减少磁盘IO，从而提高查询性能。也支持索引，但是索引是只读的。

### Innodb

1. Innodb支持事务，通过MVCC来获得高并发性，实现了SQL标准的4种隔离级别，Innodb还提供了插入缓冲、二次写、自适应hash、预读等高性能和高可用功能。
2. 对于表中数据存储，基于聚簇索引建立的，对主键查询有很高的性能。对于非主键索引，采用二级索引（非主键索引）来建立，必须包含主键列。

#### 插入缓冲

性能提升

#### 二次写

可靠性

#### 自适应hash

#### 异步IO



## 8.B+树

### 1.数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

B+树的索引是根据最左匹配原则的，比如一个姓名，性别，年龄。会先根据姓名来查找。根据性别年龄查找就会失效。

### 2.操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

### 3.与红黑树比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

### 4.为什么选择B+树作为索引结构？

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快。

​	每访问一个层级对应一次IO操作，因此B+树可以提高性能。3层的b+树可以表示上百万的数据，如果上百万的数据只需要三次IO，性能提高巨大。

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

哈希索引：无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 5.查询在什么时候不走（预期中的）索引？

1. 查询条件在索引列上使用函数操作，或者运算的情况
2. 查询条件字符串和数字之间的隐式转换
3. 特殊修饰符
4. 索引优化器选择最优的索引

### 优化

1. 定长`char`，非定长`varchar、text`
2. 尽可能选择小的数据类型和指定短的长度
3. 可以建一个联合索引，使用最左前缀匹配

## 9.索引

MySQL索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

MySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。

- **MyISAM:** B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。
- **InnoDB:** 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。**在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。** **因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。**

### 建立索引的几大原则

1. 最左匹配原则
2. =和in可以乱序，mysql优化器会帮你优化成索引可以识别的形式
3. 尽量选择区分度大的列作为索引
4. 索引列不能参与计算
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

### 联合索引

联合索引即由多列属性组成索引。

假设创建的联合索引由三个字段组成:

```
ALTER TABLE table ADD INDEX index_name (num,name,age)
```

那么当查询的条件有为:num / (num AND name) / (num AND name AND age)时，索引才生效。所以在创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段。查询的时候也尽量以这个字段为第一条件。

### 索引失效的条件

- 不在索引列上做任何操作(计算、函数、类型转换)，会导致索引失效而转向全表扫描
- 存储引擎不能使用索引条件右边的列
- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select * 
- mysql在使用不等于的时候无法使用索引会导致全表扫描
- like以通配符开头（%abc）mysql索引会失效引起全表扫描
- 字符串不加单引号索引失效

## 命令

```
SELECT @@autocommit; //查询事务提交状态
set autocommit=0; //取消自动提交
create database tran; //创建数据库
use tran; //使用数据库
create table student(id int primarykey,name varchar(10)) engine=innodb default charset=utf8; //创建表
insert into student values(1,'zhangsan'); //使用表
commit;//提交数据
set session transaction isolation level read uncommitted;//将隔离级别设置成读未提交
start transaction;//开启事务
update student set name='msb';
rollback;//回滚
set session transaction isolation level read committed;//修改隔离级别为读取已提交
set session transaction isolation level repeatable read;//
```

## 参考链接

1. [MySQL慢查询日志](https://www.cnblogs.com/kerrycode/p/5593204.html)

2. [MyISAM和InnoDB的区别](https://www.biaodianfu.com/mysql-myisam-innodb.html)
3. [MySQL性能分析方法](https://www.jianshu.com/p/3c79039e82aa)

4. 