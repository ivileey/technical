# 数据库

## 1.事务的基本要素

事务的基本要素（ACID）：

- 原子性：要么都成功要么都失败，通过undo log实现
- 一致性：事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
- 隔离型：并发访问数据库时，一个用户的事务不被其他事务所干扰。
- 持久性：一个事务被提交之后。它对数据库中数据的改变是持久的。通过Redo log实现。

## 2.事务的隔离级别

- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。
- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。
- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。
- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**

## 3.如何解决事务的并发问题(脏读，幻读)

产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。

## 4.MVCC多版本并发控制

事务隔离机制的实现基于锁机制和并发调度。并发调度使用的是MVCC多版本并发控制，通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。用以实现提交读和可重复读两种隔离级别。MVCC利用多版本思想，写操作更新最新的版本快照，读操作去读旧版本快照。

在MVCC中事务的修改操作（DELETE、Insert、Update）会为数据行新增一个版本快照。

### 版本号

- 系统版本号SYS_ID：是一个递增的数字，每开启一个新的事务，系统版本号就会自动递增。
- 事务版本号TRX_ID：事务开始时的系统版本号。

### Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。

### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。

## 5.binlog,redolog,undolog都是什么，起什么作用？

- redo log(重做日志)：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redolog进行重做，从而达到事务的持久性这一特性。
- binlog(归档日志)：用于复制，在主从复制中，从库利用主库上的binlog进行重播。实现主从同步。用于数据库基于时间点的还原。
- undo log(回滚日志)：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

## 6.InnoDB的行锁/表锁

- **行级锁**：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，加锁的开销最大。行级锁分为共享锁排他锁。

  特点：开销大，加锁慢，会出现死锁；锁定粒度最小，发生冲突的概率最低，并发度也最高。

- **表级锁**：表级锁是Mysql中锁定粒度最大的一种锁，表示对整张表加锁，实现简单，资源消耗较少。表级锁分为共享锁和排他锁。

  特点：开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。

### MySQL中InnoDB引擎的行锁是怎么实现的？

  答：InnoDB是基于索引来完成行锁

  例: select * from tab_with_index where id = 1 for update;

  for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起

## 7.myisam和innodb的区别，什么时候选择myisam？

innodb支持ACID事务的支持。并且提供行级锁和表级锁。MyIASM不提供事务的支持，也不支持行级锁和外键。

- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

如果没有特别的需求，使用默认的`Innodb`即可。

MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。

Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。

## 8.B+树

### 1.数据结构

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

B+树的索引是根据最左匹配原则的，比如一个姓名，性别，年龄。会先根据姓名来查找。根据性别年龄查找就会失效。

### 2.操作

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。

### 3.与红黑树比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

### 4.为什么选择B+树作为索引结构？

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快。

​	每访问一个层级对应一次IO操作，因此B+树可以提高性能。3层的b+树可以表示上百万的数据，如果上百万的数据只需要三次IO，性能提高巨大。

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

哈希索引：无法用于排序与分组，只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

### 5.查询在什么时候不走（预期中的）索引？

1. 查询条件在索引列上使用函数操作，或者运算的情况
2. 查询条件字符串和数字之间的隐式转换
3. 特殊修饰符
4. 索引优化器选择最优的索引

### 优化

1. 定长`char`，非定长`varchar、text`

2. 尽可能选择小的数据类型和指定短的长度

3. 可以建一个联合索引，使用最左前缀匹配

### 建立索引的几大原则

1. 最左匹配原则
2. =和in可以乱序，mysql优化器会帮你优化成索引可以识别的形式
3. 尽量选择区分度大的列作为索引
4. 索引列不能参与计算
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

## 命令

```
SELECT @@autocommit; //查询事务提交状态
set autocommit=0; //取消自动提交
create database tran; //创建数据库
use tran; //使用数据库
create table student(id int primarykey,name varchar(10)) engine=innodb default charset=utf8; //创建表
insert into student values(1,'zhangsan'); //使用表
commit;//提交数据
set session transaction isolation level read uncommitted;//将隔离级别设置成读未提交
start transaction;//开启事务
update student set name='msb';
rollback;//回滚
set session transaction isolation level read committed;//修改隔离级别为读取已提交
set session transaction isolation level repeatable read;//
```

