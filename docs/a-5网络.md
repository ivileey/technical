# 网络

## TCP和UDP的区别 

1、基于连接与无连接；

2、对系统资源的要求（TCP较多，UDP少）；

3、UDP程序结构较简单；

4、流模式与数据报模式 ；

5、TCP保证数据正确性，UDP可能丢包；

6、TCP保证数据顺序，UDP不保证。

## UDP不可靠会丢包，为什么还用它，怎么解决UDP不可靠

UDP具有高实时性，在我们进行视频通话时，就需要UDP，而不是TCP需要等待回传确认信息

- UDP socket缓冲区满造成的UDP丢包：在socket缓冲区满造成丢包的情况下，可以通过增大缓冲区的方法来缓解UDP丢包问题。但是，如果服务已经过载了，简单的增大缓冲区并不能解决问题，反而会造成滚雪球效应，造成请求全部超时，服务不可用。
- UDP socket缓冲区过小造成的UDP丢包：
- ARP缓存过期导致UDP丢包：ARP 的缓存时间约10分钟，APR 缓存列表没有对方的 MAC 地址或缓存过期的时候，会发送 ARP 请求获取 MAC 地址，在没有获取到 MAC 地址之前，用户发送出去的 UDP 数据包会被内核缓存到 arp_queue 这个队列中，默认最多缓存3个包，多余的 UDP 包会被丢弃。当然我们可以通过 echo 30 > /proc/sys/net/ipv4/neigh/eth1/unres_qlen 来增大可以缓存的 UDP 包。
- 解决 UDP 不可靠
  - 一个简单的办法来采用冗余传输的方式。
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200810112456450.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pc2h1aWFlZQ==,size_16,color_FFFFFF,t_70)
  - 如果必须使用UDP，而且丢包又是不能接受的，只好自己实现确认和重传，说白了，就是自己实现TCP（当然是部分和有限的简单实现）。
    UDP是而向无连接的，用户在实施UDP编程时，必须制定上层的协议，包括流控制，简单的超时和重传机制，如果不要求是实时数据，我想TCP可能会更适合你！

## tcp服务器负载高在什么地方

## TCP三次握手和四次挥手

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200807163342139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pc2h1aWFlZQ==,size_16,color_FFFFFF,t_70)

### 三次握手

- 假如服务器B和客户机A通讯，当A要和B通信时，

  （1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

  （2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

  （3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。![在这里插入图片描述](https://img-blog.csdnimg.cn/20200809090528372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pc2h1aWFlZQ==,size_16,color_FFFFFF,t_70)

### 四次挥手

（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。**(状态位FIN=1,发送seq=J)**

（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。**(状态位ACK=1，发送ack=J+1)**

（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。**(状态位FIN=1,发送seq=K)**

（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。**(状态位ACK=1，ack=K+1)**

但是实际上A不会直接CLOSE，还会进入一个等待时间状态TIME_WAIT，持续2倍的MSL（Maximum Segment Lifetime，报文在网络上能存活的最大时间）。过了这个状态才会CLOSE。

### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

### 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？

原因有二：
一、保证TCP协议的全双工连接能够可靠关闭
二、保证这次连接的重复数据段从网络中消失

### TCP协议如何保证可靠传输

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

## 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

## Tomcat的加载过程

Tomcat的类加载机制是违反了双亲委派模型的，对于一些未加载的非基础类，各个web应用自己的类加载器（WebAppClassLoader）会优先加载，加载不到时再交给commonClassLoader加载

## 网络编程

###  创建socket的过程





## http在哪一层，http的状态码

- 应用层
  1xx：指示信息--表示请求已接收，继续处理
  2xx：成功--表示请求已被成功接收、理解、接受
  3xx：重定向--要完成请求必须进行更进一步的操作
  4xx：客户端错误--请求有语法错误或请求无法实现
  5xx：服务器端错误--服务器未能实现合法的请求

  ```
  200 OK                        //客户端请求成功
  400 Bad Request               //客户端请求有语法错误，不能被服务器所理解
  401 Unauthorized              //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
  403 Forbidden                 //服务器收到请求，但是拒绝提供服务
  404 Not Found                 //请求资源不存在，eg：输入了错误的URL
  500 Internal Server Error     //服务器发生不可预期的错误
  503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常
  ```

## http1.0和http1.1区别

- 长连接 HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。
- 节约带宽
  HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。
  这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。
  另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。
- HOST域
  现在可以web server例如tomat，设置虚拟站点是非常常见的，也即是说，web server上的多个虚拟站点可以共享同一个ip和端口。
  HTTP1.0是没有host域的，HTTP1.1才支持这个参数。

## http1.1和http2.0的区别

- 多路复用
  HTTP2.0使用了(类似epoll)多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
- 数据压缩
  HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。
- 服务器推送
  当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。

## http如何判断响应内容发送完毕

- 客户端可以根据头部字段content-length来判断消息是否发送完毕
- Transfer-Encoding
  但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用"Transfer-Encoding: chunked"这样的方式来代替Content-Length。 由一个标明长度为0的chunk标示结束。

## 网络的七层模型

物理层-> 数据链路层 -> 网络层 ->传输层 ->会话层 ->表示层-> 应用层
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020080715350920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pc2h1aWFlZQ==,size_16,color_FFFFFF,t_70)
TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接

## 其中应用层包括:

1. 超文本传输协议（HTTP）:万维网的基本协议；
2. 文件传输（TFTP简单文件传输协议）；
3. 远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；
4. 网络管理（SNMP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；
5. 域名系统（DNS），该系统用于在internet中将域名及其公共广播的网络节点转换成IP地址。

## socket

- socket是计算机网络编程的基础，TCP/UDP收发消息都靠它。web服务器底层依赖它，MySQL关系数据库、Redis内存数据库底层依赖它。我们用微信聊天、玩网络游戏时也离不开它。

## 参考链接：

1. [七层协议和四层协议](https://www.cnblogs.com/aspirant/p/10813139.html)
2. [三次握手和四次挥手，以及tcp报头](https://www.cnblogs.com/aspirant/p/7224696.html)
3. [TCP报文格式](https://blog.csdn.net/a19881029/article/details/29557837)
4. [tcp的seq和ack的计算方法](https://blog.csdn.net/HappyRocking/article/details/78198776)
5. [http1.0和http1.1和http2.0的区别](https://www.cnblogs.com/aspirant/p/10833143.html)
6. [htttp keep-alive 模式](https://www.cnblogs.com/skynet/archive/2010/12/11/1903347.html)
7. [ServerSocket和Socket的区别](https://blog.csdn.net/J080624/article/details/78468396)
8. [Tomcat类加载机制](https://www.cnblogs.com/aspirant/p/8991830.html)
9. [http](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md)
10. [socket](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md)
11. [计算机网络常见问题](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)

