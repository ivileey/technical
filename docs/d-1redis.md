# Redis

> 作者：Yuner

简单来说 **Redis 就是一个使用 C 语言开发的数据库**，不过与传统数据库不同的是 **Redis 的数据是存在内存中的** ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。

另外，**Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。**

**Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。**

## 一 Redis五种基本类型

> redis键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。

1. STRING 字符串，整数或者浮点数 

   - 是通过定义一个SDS简单动态字符串数据结构用作Redis的默认字符串表示,Redis 的 SDS API 是安全的，不会造成缓冲区溢出,会自动扩展空间。
   - **应用场景** ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。
   - **常用命令:** `set,get,strlen,exists,dect,incr,setex` 等等。

2. LIST 链表

   - 一个双向链表
   - `rpush,lpop,lpush,rpop,lrange、llen` 等。
   - **应用场景:** 发布与订阅或者说消息队列、慢查询。

3. hash

   - hash数组+链表，当元素数量等于数组长度时进行扩容rehash，当元素数量少于数组长度的10%时，开始减小数组长度
   - **常用命令：** `hset,hmset,hexists,hget,hgetall,hkeys,hvals` 等。
   - **应用场景:** 系统中对象数据的存储。

4. set

   - set 无序集合，一个列表数据，可以方便的求出共同关注和共同粉丝，共同喜好
   - **常用命令：** `sadd,spop,smembers,sismember,scard,sinterstore,sunion` 等
   - **应用场景:** 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

5. sorted set / zset

   - 增加了一个权重参数score，使元素能够按score进行有序排列，内部使用跳跃表数据结构。

   - **常用命令：** `zadd,zcard,zscore,zrange,zrevrange,zrem` 等。
   - **应用场景：** 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

##  二 Redis中的数据结构

### 字典

- dictht是一个hash表结构，使用拉链法解决哈希冲突。
- dict中维护两个dictht，为了方表rehash操作，rehash不是一次性完成的，通过记录dict的rehashidx完成，从0开始每执行一次rehash都会递增。

### 跳跃表

- 是有序集合的底层实现之一
- 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。
- 从上层指针开始查找，找到对应区间之后再到下层找
- 与红黑树相比：插入速度非常快，不需要旋转；更容易实现；支持无锁操作

## 三 Redis的使用场景

> 计数器
>
> 缓存
>
> 查找表 ：DNS记录
>
> 消息队列：不过最好使用kafka，RabbitMQ
>
> 会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
>
> 分布式锁实现：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
>
> 其他：set可以实现共同好友，zset可以实现排行榜。



## 四 Redis与Memcached的区别和共同点

共同点：

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。

不同点：

1. 数据类型：Memcached仅支持字符串类型，Redis支持五种类型。
2. 数据持久化：Redis支持RDB快照和AOF日志，Memcached不支持持久化。
3. 分布式： Memcached不支持分布式，只能在客户端使用一致性哈希来实现分布式。Redis Cluster实现了分布式。
4. 内存管理机制：**Redis 有灾难恢复机制。**Redis可以将一些很久没用的value交换到磁盘，Memcached会一直在内存中。
5. **Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。** （Redis 6.0 引入了多线程 IO ）
6. **Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。**
7. **Memcached过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。**

### 分布式缓存常见的技术选型方案有哪些？

分布式缓存的话，使用的比较多的主要是 **Memcached** 和 **Redis**。不过，现在基本没有看过还有项目使用 **Memcached** 来做缓存，都是直接用 **Redis**。

Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。

分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用的信息。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。

## 五 Redis键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。



## 六 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

	 volatile-lru： 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
	 volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
	 volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
	 allkeys-lru：从所有数据集中任意选择数据进行淘汰
	 allkeys-random：从所有数据集中任意选择数据进行淘汰
	 noeviction：禁止驱逐数据，新写入数据操作会报错
	 
	 4.0 版本后增加以下两种：
	
	 volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
	 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。



## 七 Redis持久化

### RDB持久化

将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量很大，保存快照的时间会很长。

### AOF持久化

将写命令添加到 AOF 文件（Append Only File）的末尾。

- always 选项会严重减低服务器的性能；
- everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

## 八 Redis事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

## 九 事件

### 文件事件

服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。

Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。

### 时间事件

服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。

时间事件又分为：

- 定时事件：是让一段程序在指定的时间之内执行一次；
- 周期性事件：是让一段程序每隔指定时间就执行一次。

Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。

### 事件的调度与执行

服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。

##  十 复制

通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。

一个从服务器只能有一个主服务器，并且不支持主主复制。

### 连接过程

1. 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
2. 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
3. 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

### 主从链

随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。

### 心跳检测

在命令传播阶段，**从服务器默认以每秒一次的频率**，向主服务器发送命令：

***REPLCONF ACK <replication_offset>** //replication_offset*是从服务器当前的复制偏移量。

心跳检测的作用：检测主服务器的网络连接状态；辅助实现*min-slaves*选项；检测命令丢失。

## 十一 Sentinel

Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

## 十二 分片

分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。

假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。

- 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。
- 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。

根据执行分片的位置，可以分为三种分片方式：

- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

## 十四 为什么 Redis 一开始选择单线程模型（单线程的好处）？

- 使用 IO多路复用技术，同时监听多个文件描述符FD，由于大多是操作是基于内存的所以每次操作都非常快。
- 可维护性高，由于是单线程的不用考虑并发读写问题
- 基于内存，单线程状态下效率还是很高（一秒10万个用户请求），还可以使用redis分片技术。

## 为什么 Redis 在 6.0 之后加入了多线程（在某些情况下，单线程出现了缺点，多线程可以解决）？

因为读写网络的read/write系统调用在Redis执行期间占用了大部分CPU时间，如果把网络读写做成多线程的方式对性能会有很大提升。

Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH/LPOP 等等的并发问题。

Redis 在最新的几个版本中加入了一些可以被其他线程异步处理的删除操作，也就是我们在上面提到的 UNLINK、FLUSHALL ASYNC 和 FLUSHDB ASYNC。

## 十五 缓存穿透

### 什么是缓存穿透

缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。

### 缓存穿透有哪些解决办法？

布隆过滤器，**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**

## 十六 缓存雪崩

### 什么是缓存雪崩

实际上，缓存雪崩描述的就是这样一个简单的场景：**缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。**

举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。

还有一种缓存雪崩的场景是：**有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。** 这样的情况，有下面几种解决办法：

举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。

### 解决办法

**针对 Redis 服务不可用的情况：**

1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。
2. 限流，避免同时处理大量的请求。

**针对热点缓存失效的情况：**

1. 设置不同的失效时间比如随机设置缓存的失效时间。
2. 缓存永不失效。

## 十六 如何保证缓存和数据库数据的一致性

Cache Aside Pattern（旁路缓存模式） 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。

如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：

1. **缓存失效时间变短（不推荐，治标不治本）** ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。
2. **增加cache更新重试机制（常用）**： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。

## 其他 Redis中看不懂的算法

- HyperLogLog
- 

## 参考链接

1. 《redis设计与实现》
2. [redis简介](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
3. [redis5种基本类型](https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/)
4. [阿里云Redis开发规范](https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px)
5. [为什么不使用bigkey](https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&mid=2247483677&idx=1&sn=5c320b46f0e06ce9369a29909d62b401&chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&scene=21#wechat_redirect)
6. [为什么要使用缓存](https://github.com/Snailclimb/JavaGuide/blob/master/docs/database/Redis/some-concepts-of-caching.md)

