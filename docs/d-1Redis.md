# Redis

> 作者：Yuner



## Redis五种基本类型

> redis键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。

1. STRING 字符串，整数或者浮点数 

   - 是通过定义一个SDS简单动态字符串数据结构用作Redis的默认字符串表示,Redis 的 SDS API 是安全的，不会造成缓冲区溢出,会自动扩展空间。
   - **应用场景** ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。
   - **常用命令:** `set,get,strlen,exists,dect,incr,setex` 等等。

2. LIST 链表

   - 一个双向链表
   - `rpush,lpop,lpush,rpop,lrange、llen` 等。
   - **应用场景:** 发布与订阅或者说消息队列、慢查询。

3. hash

   - hash数组+链表，当元素数量等于数组长度时进行扩容rehash，当元素数量少于数组长度的10%时，开始减小数组长度
   - **常用命令：** `hset,hmset,hexists,hget,hgetall,hkeys,hvals` 等。
   - **应用场景:** 系统中对象数据的存储。

4. set

   - set 无序集合，一个列表数据，可以方便的求出共同关注和共同粉丝，共同喜好
   - **常用命令：** `sadd,spop,smembers,sismember,scard,sinterstore,sunion` 等
   - **应用场景:** 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景

5. sorted set / zset

   - 增加了一个权重参数score，使元素能够按score进行有序排列，内部使用跳跃表数据结构。

   - **常用命令：** `zadd,zcard,zscore,zrange,zrevrange,zrem` 等。
   - **应用场景：** 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。

##  Redis中的数据结构

### 字典

- dictht是一个hash表结构，使用拉链法解决哈希冲突。
- dict中维护两个dictht，为了方表rehash操作，rehash不是一次性完成的，通过记录dict的rehashidx完成，从0开始每执行一次rehash都会递增。

### 跳跃表

- 是有序集合的底层实现之一
- 跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。
- 从上层指针开始查找，找到对应区间之后再到下层找
- 与红黑树相比：插入速度非常快，不需要旋转；更容易实现；支持无锁操作

## Redis的使用场景

> 计数器
>
> 缓存
>
> 查找表 ：DNS记录
>
> 消息队列：不过最好使用kafka，RabbitMQ
>
> 会话缓存：可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。
>
> 分布式锁实现：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
>
> 其他：set可以实现共同好友，zset可以实现排行榜。



## Redis与Memcached的不同点

1. 数据类型：Memcached仅支持字符串类型，Redis支持五种类型。
2. 数据持久化：Redis支持RDB快照和AOF日志，Memcached不支持持久化。
3. 分布式： Memcached不支持分布式，只能在客户端使用一致性哈希来实现分布式。Redis Cluster实现了分布式。
4. 内存管理机制：Redis可以将一些很久没用的value交换到磁盘，Memcached会一直在内存中。



## Redis键的过期时间

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。

对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。



## 数据淘汰策略

可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。

Redis 具体有 6 种淘汰策略：

	- 

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。

使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。



## Redis持久化

### RDB持久化

将某个时间点的所有数据都存放到硬盘上。

可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。

如果系统发生故障，将会丢失最后一次创建快照之后的数据。

如果数据量很大，保存快照的时间会很长。

### AOF持久化

将写命令添加到 AOF 文件（Append Only File）的末尾。

- always 选项会严重减低服务器的性能；
- everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；
- no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量

随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。

## Redis事务

一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。

事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。

Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。

## 事件

### 文件事件

### 时间事件



## 参考链接

1. 《redis设计与实现》

2. [redis简介](https://github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md)
3. [redis5种基本类型](https://www.wmyskxz.com/2020/02/28/redis-1-5-chong-ji-ben-shu-ju-jie-gou/)
4. [阿里云Redis开发规范](https://www.infoq.cn/article/K7dB5AFKI9mr5Ugbs_px)
5. [为什么不使用bigkey](https://mp.weixin.qq.com/s?__biz=Mzg2NTEyNzE0OA==&mid=2247483677&idx=1&sn=5c320b46f0e06ce9369a29909d62b401&chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&scene=21#wechat_redirect)

